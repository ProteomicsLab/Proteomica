import java.awt.Button;
import java.awt.Checkbox;
import java.awt.CheckboxGroup;
import java.awt.Color;
import java.awt.Cursor;
import java.awt.Dialog;
import java.awt.Event;
import java.awt.FileDialog;
import java.awt.Frame;
import java.awt.Graphics;
import java.awt.GridLayout;
import java.awt.Label;
import java.awt.Panel;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.awt.event.FocusEvent;
import java.awt.event.MouseEvent;
import java.awt.event.MouseListener;
import java.awt.event.MouseMotionListener;
import java.awt.event.WindowEvent;
import java.awt.event.WindowListener;
import java.io.BufferedReader;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.util.StringTokenizer;
import java.util.Vector;

import ij.IJ;
import ij.ImagePlus;
import ij.ImageStack;
import ij.Prefs;
import ij.gui.GenericDialog;
import ij.gui.ImageCanvas;
import ij.gui.ImageWindow;
import ij.gui.OvalRoi;
import ij.gui.Roi;
import ij.gui.StackWindow;
import ij.measure.Measurements;
import ij.measure.ResultsTable;
import ij.plugin.PlugIn;
import ij.plugin.filter.Analyzer;
import ij.process.ImageProcessor;
import ij.process.ImageStatistics;

public class Proteomica_ implements PlugIn{
	ImagePlus imp;
	@Override
	public void run(String arg) {
		// TODO Auto-generated method stub
		// Start :  Added by BhushanNK open image compulsorily
		imp = IJ.getImage();         
		final ProteinProfiler mp = new ProteinProfiler(imp);
	}	
}

class ProteinProfiler extends Dialog implements  ActionListener, WindowListener{
	ImageStack stack;
    public static final String[] roiTypes = {"Circles","Rectangles"};
	int numSlices;
	ImagePlus imp;
	ImageCanvas ic;

	private CircleArranger ca;
	Panel panel;
	
	protected Button spacing, diam, measure, measureRT, histograms, saveGrid, readGrid, quit;
	//start: added button for seperate steps involved in 2DE gel image analysis : by Bhushan N K
	protected Button openMatchSet, autoPreProcess, autoWarp, meanParentGel, autoSegment, autoQuantify, generateStats;      
	//end: added button for seperate steps involved in 2DE gel image analysis : by Bhushan N K  
	
	Checkbox manyFiles, oneFile, resultTable;
	CheckboxGroup outputType;
	int rows,columns,diameter,width,height,roiChoice;
	String outPath,gridDirectory,outFile;
	int INVALID = -9999999;
	int decimalPlaces = 2;

	public ProteinProfiler(ImagePlus imp){

		super(IJ.getInstance(),"Proteomica - IIT Bombay",false);
		addWindowListener(this);
		this.imp = imp;
		ic = imp.getWindow().getCanvas();
		rows = (int)Prefs.get("ProteinProfiler.rows", 6);
		columns = (int)Prefs.get("ProteinProfiler.columns", 8);
		diameter = (int)Prefs.get("ProteinProfiler.diameter", 20);
		width = (int)Prefs.get("ProteinProfiler.width", 20);
		height = (int)Prefs.get("ProteinProfiler.height", 20);
		roiChoice = (int)Prefs.get("ProteinProfiler.roiChoice", 0);
		gridDirectory = (String)Prefs.get("ProteinProfiler.gridDirectory", " ");
		ca = new CircleArranger(imp,ic,rows,columns,diameter,width,height,roiChoice);
		if (imp.getStackSize()>1)
			new StackWindow(imp, ca).addWindowListener(this); // 4/13/2012 per Andrew Smolak
		else
			new ImageWindow(imp, ca).addWindowListener(this); // 4/13/2012 per Andrew Smolak
		outPath = Prefs.get("ProteinProfiler.outPath", "none");
		addWindowListener(this);
		stack = imp.getStack();
		numSlices = imp.getStackSize();
		setup();

	}
	public void setup() {
		setLayout(new GridLayout(10,1,5,5));
		spacing = new Button("Reset Grid");
		spacing.addActionListener(this);
		//start: creating awt buttons Added by Bhushan N K
		//openMatchSet, autoPreProcess, autoWarp, meanParentGel, autoSegment, autoQuantify, generateStats; 
		
		openMatchSet = new Button("Matchset");//button for creating match set
		openMatchSet.addActionListener(this);
		
		autoPreProcess = new Button("Pre-Process");//button for pre-processing of the gel images
		autoPreProcess.addActionListener(this);
		
		autoWarp = new Button("Match & Align");// button for to auto warp the gel image with reference with unwarpJ
		autoWarp.addActionListener(this);
		
		meanParentGel = new Button("Global Gel");// button for creating the global mean gel generated by summing the all the aligned gel and reference gel  
		meanParentGel.addActionListener(this);
		
		autoSegment = new Button("Segment");// button for  segmentation of the mean gel with pre-set default parameters 
												//optimised for the segmentation of the gel images
		autoSegment.addActionListener(this);
		
		autoQuantify = new Button("Quantify");// button for quantification of the detected roi(protein spots on all gel images individually)
		autoQuantify.addActionListener(this);
		
		generateStats = new Button("Statistics");// button for generating statistics of all  
		generateStats.addActionListener(this);
		
		//start: Commented by Bhushan N K unused code  
		
/*		diam = new Button("Change ROI");
		diam.addActionListener(this);
		saveGrid = new Button("Save Grid");
		saveGrid.addActionListener(this);
		readGrid = new Button("Read Grid");
		readGrid.addActionListener(this);
		measure = new Button("Measure file(s)");
		measure.addActionListener(this);
		measureRT = new Button("Measure RT");
		measureRT.addActionListener(this);
		histograms = new Button("Histograms");
		histograms.addActionListener(this);
*/
		//end: Commented by Bhushan N K unused code 
		
		quit = new Button("Quit");
		quit.addActionListener(this);
		panel = new Panel();
		panel.setLayout(new GridLayout(1,3,5,5));
		Label l = new Label("Command Workflow",Label.CENTER);
		add(l);

		//Start: Commented by Bhushan N K  unused code 
		// checkbox group and controls not required		
/*		outputType = new CheckboxGroup();
		oneFile = new Checkbox("Single");
		oneFile.setCheckboxGroup(outputType);
		panel.add(oneFile);
		manyFiles = new Checkbox("Many");
		manyFiles.setCheckboxGroup(outputType);
		panel.add(manyFiles);
		add(panel);
		oneFile.setState(true);
		add(measure);
		add(measureRT);
		add(histograms);
		add(spacing);
		add(diam);
		add(saveGrid);
		add(readGrid);*/
		//End: Commented by Bhushan N K  unused code 
		// checkbox group and controls not required		
		//openMatchSet, autoPreProcess, autoWarp, meanParentGel, autoSegment, autoQuantify, generateStats;
		
		//start : Added by Bhushan N K new controls 
		add(openMatchSet);
		add(autoPreProcess);
		add(autoWarp);
		add(meanParentGel);
		add(autoSegment);
		add(autoQuantify);
		add(generateStats);
		//End : Added by Bhushan N K new controls
		
		add(quit);
 		pack();
 		show();
    }

	//Start : Commented by Bhushan new actions performed is defined for new set of actions 
	/*	public void  actionPerformed(ActionEvent e) {
		Object b = e.getSource();
		if (b == spacing){
			synchronized(ca.resource){
				if(getSpacing())
					ca.initGrid(rows,columns,diameter,width,height,roiChoice);
					ca.resetHistory();
			}
		}else if (b == diam){
			synchronized(ca.resource){
				if(getDiam())
					ca.reviseDiam(diameter,width,height,roiChoice);
			}
		} else if (b == measure){
			doMeasurements(); 
		} else if (b == measureRT){
			doMeasureRT();
		} else if (b == histograms){
			doHistograms();
		} else if (b == saveGrid){
			saveGridFile();
		} else if (b == readGrid){
			readGridFile();
		} else if (b == quit){
			shutDown();
		}
	}
*/
	public void  actionPerformed(ActionEvent e) {
		Object b = e.getSource();
		if (b == spacing){
			synchronized(ca.resource){
				if(getSpacing())
					ca.initGrid(rows,columns,diameter,width,height,roiChoice);
					ca.resetHistory();
			}
		}else if (b == diam){
			synchronized(ca.resource){
				if(getDiam())
					ca.reviseDiam(diameter,width,height,roiChoice);
			}
		} else if (b == measure){
			doMeasurements(); 
		} else if (b == measureRT){
			doMeasureRT();
		} else if (b == histograms){
			doHistograms();
		} else if (b == saveGrid){
			saveGridFile();
		} else if (b == readGrid){
			readGridFile();
		} else if (b == quit){
			shutDown();
		}
	}

	public void saveGridFile() {
		Frame fram = new Frame();
		FileDialog fd = new FileDialog(fram, "Output file to save grid", FileDialog.SAVE);
		fd.setDirectory(gridDirectory);
		fd.setVisible(true);
		gridDirectory = fd.getDirectory();
		String filename = fd.getFile();
		if ((gridDirectory == null) || (filename == null)) {
			return;
		}
		try {
			FileWriter fw = new FileWriter(gridDirectory + filename);
			if(ca.roiChoice == 0){
				fw.write(ca.rows+"\t"+ca.columns+"\t"+ca.diameter+"\n");
			}else{
				fw.write(ca.rows+"\t"+ca.columns+"\t"+ca.width+"\t"+ca.height+"\n");
			}
			int ind = 0;
			for (int row = 0; row < ca.rows; row++){
				for (int column = 0; column < ca.columns; column++){
					fw.write((int)ca.x[ind]+"\t"+(int)ca.y[ind++]+"\n");
				}
			}
			fw.close();
		} catch (IOException e) {
			IJ.error("IOException exception");
		} catch (SecurityException e) {
			IJ.error("Security exception");
		}
		Prefs.set("ProteinProfiler.gridDirectory", gridDirectory);

	}

	public void readGridFile() {
		FileReader fr = null;
		BufferedReader br = null;
		String path = null;
		Frame f = new Frame();
		FileDialog fd = new FileDialog(f, "Grid file", FileDialog.LOAD);
		fd.setDirectory(gridDirectory);
		fd.setVisible(true);
		path = fd.getDirectory();
		String filename = fd.getFile();
		if ((path == null) || (filename == null)) {
			return;
		}
		String gridPath = path + filename;
		try{
			fr = new FileReader(gridPath);
			br = new BufferedReader(fr);
		}catch(FileNotFoundException e1){
			return;
		}
		try{
			Vector listPoints = new Vector(0, 16);
			String line;
			String nameString = null;
			String groupString = null;
			boolean firstLine = true;
			while ((line = br.readLine()) != null) {
				line = line.trim();
				int[] v = new int[4];
				for(int i = 0; i < 2; i++){
					v[i] = getTokenInteger(line, i);
				}
				if(firstLine){
					v[2] = getTokenInteger(line, 2);
					v[3] = getTokenInteger(line, 3);
				}

				if((v[0] != INVALID)&&(v[1] != INVALID)){
					listPoints.addElement(v);
				}
			}
			fr.close();
			int nLines = listPoints.size();
			if(nLines < 2){
				IJ.showMessage("Invalid grid file.");
				return;
			}
			int[] values = new int[3];
			values = (int[])listPoints.elementAt(0);
			int rowsTemp = values[0];
			int columnsTemp = values[1];
			int diameterTemp = values[2];
			int widthTemp = values[2];
			int heightTemp = values[3];
			int roiChoiceTemp = 0;
			
			if(diameterTemp == INVALID){
				IJ.showMessage("Invalid grid file.  Should have 3 numbers on first line.");
				return;
			}
			if((heightTemp == INVALID)||(heightTemp < 1)){
				roiChoiceTemp = 0;
			}else{
				roiChoiceTemp = 1;
			}
			int n = rowsTemp*columnsTemp;
			if(n != (nLines-1)){
				IJ.showMessage("Invalid grid file.  Wrong number of lines.");
				return;
			}
			synchronized(ca.resource){
				rows = rowsTemp;
				ca.rows = rowsTemp;
				columns = columnsTemp;
				ca.columns = columnsTemp;
				diameter = diameterTemp;
				width = widthTemp;
				height = heightTemp;
				roiChoice = roiChoiceTemp;
				ca.diameter = diameter;
				ca.width = width;
				ca.height = height;
				ca.roiChoice = roiChoice;
				ca.resetHistory();
				ca.x = new double[n];
				ca.y = new double[n];
				for (int i = 0; i < n; i++){
					int[] v = (int[])listPoints.elementAt(i+1);
					ca.x[i] = v[0] + 0.5;
					ca.y[i] = v[1] + 0.5;
				}
			}

		} catch (IOException e) {
			IJ.error("IOException exception");
		}
		Prefs.set("ProteinProfiler.gridDirectory", path);
		imp.draw();
	}
	//The first token in the string is in posn 0.
	String getTokenString(String line,int posn){
		StringTokenizer st = new StringTokenizer(line);
		int ntok = st.countTokens();
		String result = null;
		if(ntok > posn){
			for (int i = 0; i <= posn; i++){
				result = st.nextToken();
			}
		}
		return result;
	}
	//The first token in the string is in posn 0.
	int getTokenInteger(String line, int posn){
		int value = INVALID;
		String string = getTokenString(line,posn);
		if (string == null) return value;
		try {
      		value = Integer.parseInt(string );
 		} catch ( Exception e ) {}
		return value;
    }
	String saveFile(String directory, int row, int column, float[] data, String type){
		String name = stripExtension(imp.getTitle());
		String fullPath = null;
		for (int i = 0; i < 1000; i++){
			if(i == 0){
				fullPath = directory+name+"_"+(row+1)+"_"+(column+1)+".txt";
			}else{
				fullPath = directory+name+"_"+(row+1)+"_"+(column+1)+"_"+i+".txt";
			}
			File file = new File(fullPath);
			if(!file.exists()){
				try {
					FileWriter fw = new FileWriter(fullPath);
					int n = data.length;
					for (int iSlice = 0; iSlice < n; iSlice++){
						fw.write((iSlice+1)+"\t"+IJ.d2s(data[iSlice],5)+"\n");
					}
					fw.close();
				} catch (IOException e) {
					IJ.error("IOException exception");
				} catch (SecurityException e) {
					IJ.error("Security exception");
				}
				return directory;
			}
		}
		IJ.error("Not saving "+ directory+name+".tif because too many similar files exist");
		return null;
	}
	void saveFileFull(int rows, int columns, float[][] data){
		int nSpots = data.length;
		if(nSpots == 0)return;
		int nFrames = data[0].length;
		if(nFrames == 0)return;
		try {
			FileWriter fw = new FileWriter(outPath+outFile);
			for (int iSlice = 0; iSlice < nFrames; iSlice++){
				fw.write((iSlice+1)+"\t");
				for (int i = 0; i < (nSpots-1); i++){
					fw.write(IJ.d2s(data[i][iSlice],decimalPlaces)+"\t");
				}
				fw.write(IJ.d2s(data[nSpots-1][iSlice],decimalPlaces)+"\n");
			}
			fw.close();
		} catch (IOException e) {
			IJ.error("IOException exception");
		} catch (SecurityException e) {
			IJ.error("Security exception");
		}
		return;
	}
	//Modified from ImageJ code by Wayne Rasband
    String stripExtension(String name) {
        if (name!=null) {
            int dotIndex = name.lastIndexOf(".");
            if (dotIndex>=0)
                name = name.substring(0, dotIndex);
		}
		return name;
    }
	public boolean getSpacing(){
		GenericDialog gd = new GenericDialog("Parameters");
        gd.addNumericField("rows", rows, 0);
        gd.addNumericField("columns", columns, 0);
        gd.addNumericField("diameter (used for circles)", diameter, 0);
        gd.addNumericField("width (used for rectangles)", width, 0);
        gd.addNumericField("height (used for rectangles)", height, 0);
		gd.addChoice("Roi shape: ", roiTypes, roiTypes[roiChoice]);
        gd.showDialog();
        if (gd.wasCanceled())
            return false;
        rows = (int)gd.getNextNumber();
        columns = (int)gd.getNextNumber();
        diameter = (int)gd.getNextNumber();
        width = (int)gd.getNextNumber();
        height = (int)gd.getNextNumber();
        roiChoice = gd.getNextChoiceIndex();
        Prefs.set("ProteinProfiler.rows", rows);
		Prefs.set("ProteinProfiler.columns", columns);
		Prefs.set("ProteinProfiler.diameter", diameter);
		Prefs.set("ProteinProfiler.width", width);
		Prefs.set("ProteinProfiler.height", height);
		Prefs.set("ProteinProfiler.roiChoice", roiChoice);
        return true;
    }
	public boolean getDiam(){
        GenericDialog gd = new GenericDialog("ROI");
        gd.addNumericField("diameter (used for circles)", diameter, 0);
        gd.addNumericField("width (used for rectangles)", width, 0);
        gd.addNumericField("height (used for rectangles)", height, 0);
		gd.addChoice("Roi shape: ", roiTypes, roiTypes[roiChoice]);
        gd.showDialog();
        if (gd.wasCanceled())
            return false;
        diameter = (int)gd.getNextNumber();
        width = (int)gd.getNextNumber();
        height = (int)gd.getNextNumber();
    	roiChoice = gd.getNextChoiceIndex();
 		Prefs.set("ProteinProfiler.diameter", diameter);
		Prefs.set("ProteinProfiler.width", width);
		Prefs.set("ProteinProfiler.height", height);
		Prefs.set("ProteinProfiler.roiChoice", roiChoice);
        return true;
    }
	public void doMeasurements(){
		ImageProcessor ip = imp.getProcessor();
    	double minThreshold = ip.getMinThreshold();
    	double maxThreshold = ip.getMaxThreshold();
    	synchronized(ca.resource){//Lock out checkSlice.
    		Roi roi = null;
			if (manyFiles.getState()){
				if(!getOutPath("Choose output folder")){
					IJ.showStatus("Measurement cancelled");
				}else{
					for (int row = 0; row < ca.rows; row++){
						for (int column = 0; column < ca.columns; column++){
							IJ.showStatus("Processing row "+(row+1)+", column "+(column+1));
							int ind = column + columns*row;
							if(ca.roiChoice == 0){
								roi = new OvalRoi((int)ca.x[ind], (int)ca.y[ind], ca.diameter, ca.diameter);
							}else{
								roi = new Roi((int)ca.x[ind], (int)ca.y[ind], ca.width, ca.height);
							}
							float[] data = getZAxisProfile(roi, minThreshold, maxThreshold);
							if(data != null){
								saveFile(outPath, row, column, data, "profiles");
								//IJ.write(row+" "+column+" "+IJ.d2s(data[0])+" "+IJ.d2s(data[1]));
							}//if data
						}//columns
					}//rows
					IJ.showStatus("Done");
				}//if outpath for many files
			}else{
				if(!getOutFile("Choose output file")){
					IJ.showStatus("Measurement cancelled");
				}else{
					float[][] data = new float[ca.rows*ca.columns][];
					for (int row = 0; row < ca.rows; row++){
						for (int column = 0; column < ca.columns; column++){
							IJ.showStatus("Processing row "+(row+1)+", column "+(column+1));
							int ind = column + columns*row;
							if(ca.roiChoice == 0){
								roi = new OvalRoi((int)ca.x[ind], (int)ca.y[ind], ca.diameter, ca.diameter);
							}else{
								roi = new Roi((int)ca.x[ind], (int)ca.y[ind], ca.width, ca.height);
							}
							data[ind] = getZAxisProfile(roi, minThreshold, maxThreshold);
						}//columns
					}//rows
					IJ.showStatus("Saving Results");
					saveFileFull(rows, columns, data);
					IJ.showStatus("Done");
				}//if single file, not cancelled
			}//getState
		}//synchronized
	}
	public void doMeasureRT(){
		ImageProcessor ip = imp.getProcessor();
    	double minThreshold = ip.getMinThreshold();
    	double maxThreshold = ip.getMaxThreshold();
    	synchronized(ca.resource){//Lock out checkSlice.
    		ResultsTable rt = ResultsTable.getResultsTable();
			rt.reset();
			//rt.setPrecision(0);
        	int nSlices = imp.getStack().getSize();
        	ImageStatistics[] stats = new ImageStatistics[nSlices];
			Roi roi = null;
			for (int row = 0; row < ca.rows; row++){
				for (int column = 0; column < ca.columns; column++){
					IJ.showStatus("Processing row "+(row+1)+", column "+(column+1));
					int ind = column + columns*row;
					if(ca.roiChoice == 0){
						roi = new OvalRoi((int)ca.x[ind], (int)ca.y[ind], ca.diameter, ca.diameter);
					}else{
						roi = new Roi((int)ca.x[ind], (int)ca.y[ind], ca.width, ca.height);
					}
					int measurements =  getZAxisStats(roi, minThreshold, maxThreshold, stats);
					
					//if((measurements&Measurements.SCIENTIFIC_NOTATION)!=0)
					if(stats[0] != null){
						for(int slice = 0; slice < nSlices; slice++){
							rt.incrementCounter();
							rt.addValue("Index", ind+1);
							rt.addValue("Row", row+1);
							rt.addValue("Column", column+1);
							if(((measurements&Measurements.STACK_POSITION )!=0)||(nSlices > 1))rt.addValue("Slice", slice+1);
							if((measurements&Measurements.AREA)!=0)rt.addValue("Area", stats[slice].area);
							if((measurements&Measurements.STD_DEV)!=0)rt.addValue("StdDev", stats[slice].stdDev);
							if((measurements&Measurements.MIN_MAX)!=0){
								rt.addValue("Min", stats[slice].min);
								rt.addValue("Max", stats[slice].max);
							}
							if((measurements&Measurements.CENTER_OF_MASS)!=0){
								rt.addValue("xCenterOfMass", stats[slice].xCenterOfMass);
								rt.addValue("yCenterOfMass", stats[slice].yCenterOfMass);
							}
							if((measurements&Measurements.CENTROID)!=0){
								rt.addValue("xCentroid", stats[slice].xCentroid);
								rt.addValue("yCentroid", stats[slice].yCentroid);
							}
							if((measurements&Measurements.INTEGRATED_DENSITY)!=0)rt.addValue("IntegratedDensity",stats[slice].area*stats[slice].mean);
							if((measurements&Measurements.SKEWNESS)!=0)rt.addValue("Skewness", stats[slice].skewness);
							if((measurements&Measurements.MEAN)!=0)rt.addValue("Mean", stats[slice].mean);
							if((measurements&Measurements.MODE)!=0)rt.addValue("Mode", stats[slice].mode);
							if((measurements&Measurements.MEDIAN)!=0)rt.addValue("Median", stats[slice].median);
							if((measurements&Measurements.KURTOSIS)!=0)rt.addValue("Kurtosis", stats[slice].kurtosis);
						}//slice
						//IJ.write(row+" "+column+" "+IJ.d2s(data[0])+" "+IJ.d2s(data[1]));
						rt.show("Results");
					}//if counts
				}//columns
			}//rows
			IJ.showStatus("Done");
		}//synchronized
	}
	public void doHistograms(){
		ImageProcessor ip = imp.getProcessor();
    	double minThreshold = ip.getMinThreshold();
    	double maxThreshold = ip.getMaxThreshold();
    	synchronized(ca.resource){//Lock out checkSlice.
    		ResultsTable rt = ResultsTable.getResultsTable();
			rt.reset();
			//rt.setPrecision(0);
        	int nSlices = imp.getStack().getSize();
        	ImageStatistics[] stats = new ImageStatistics[nSlices];
        	Roi roi = null;
			for (int row = 0; row < ca.rows; row++){
				for (int column = 0; column < ca.columns; column++){
					IJ.showStatus("Processing row "+(row+1)+", column "+(column+1));
					int ind = column + columns*row;
					if(ca.roiChoice == 0){
						roi = new OvalRoi((int)ca.x[ind], (int)ca.y[ind], ca.diameter, ca.diameter);
					}else{
						roi = new Roi((int)ca.x[ind], (int)ca.y[ind], ca.width, ca.height);
					}
					getZAxisStats(roi, minThreshold, maxThreshold, stats);
					if(stats[0] != null){
						for(int slice = 0; slice < nSlices; slice++){
							int[] counts = stats[slice].histogram;
							int nBins = counts.length;
							rt.incrementCounter();
							rt.addValue("Index", ind+1);
							rt.addValue("Row", row+1);
							rt.addValue("Column", column+1);
							rt.addValue("X", stats[slice].roiX);
							rt.addValue("Y", stats[slice].roiY);
							rt.addValue("Slice", slice+1);
							rt.addValue("Count", stats[slice].pixelCount);
							rt.addValue("Mean", stats[slice].mean);
							rt.addValue("StdDev", stats[slice].stdDev);
							rt.addValue("Min", stats[slice].min);
							rt.addValue("Max", stats[slice].max);
							rt.addValue("Mode", stats[slice].mode);
							for(int bin = 0; bin < nBins; bin++){
								rt.addValue(bin+"", counts[bin]);
							}
						}//slice
						//IJ.write(row+" "+column+" "+IJ.d2s(data[0])+" "+IJ.d2s(data[1]));
						rt.show("Results");
					}//if counts
				}//columns
			}//rows
			IJ.showStatus("Done");
		}//synchronized
	}
	boolean getOutPath(String prompt){
		Frame fr = new Frame();
		FileDialog fd = new FileDialog(fr, prompt,FileDialog.SAVE);
		String name = "All files and folders";
		if(outPath != "none")name = outPath+name;
		fd.setFile(name);
		fd.setVisible(true);
		String path = fd.getDirectory();
		if (path == null) {
			return false;
		}
		File testFile = new File(path);
		if (!testFile.isDirectory()) return false;
		outPath = path;
		Prefs.set("ProteinProfiler.outPath", outPath);
		return true;
	}
	boolean getOutFile(String prompt){
		Frame fr = new Frame();
		FileDialog fd = new FileDialog(fr, prompt,FileDialog.SAVE);
		String name = stripExtension(imp.getTitle())+".txt";
		fd.setFile(name);
		if(outPath != "none"){
			fd.setDirectory(outPath);
		}
		fd.setVisible(true);
		String path = fd.getDirectory();
		if (path == null) {
			return false;
		}
		outPath = path;
		Prefs.set("ProteinProfiler.outPath", outPath);
		outFile = fd.getFile();
		return true;
	}
    public void windowClosing(WindowEvent e) {
		shutDown();
	}
    public void windowClosed(WindowEvent e) {}
	public void windowActivated(WindowEvent e) {}
	public void windowDeactivated(WindowEvent e) {}
	public void focusLost(FocusEvent e) {}
	public void windowDeiconified(WindowEvent e) {}
	public void windowIconified(WindowEvent e) {}
	public void windowOpened(WindowEvent e) {}
	public void shutDown(){
		if(!imp.getWindow().isClosed()){
			if (imp.getStackSize()>1)
				new StackWindow(imp);
			else
				new ImageWindow(imp);
		}
		hide();
		//setVisible(false);
		dispose();
	}
    float[] getZAxisProfile(Roi roi, double minThreshold, double maxThreshold) {
        ImageStack stack = imp.getStack();
        imp.setRoi(roi);
        int size = stack.getSize();
		int measurements = Analyzer.getMeasurements();
		float[] values = new float[size];
		int oldSlice = imp.getCurrentSlice();
		for (int slice=1; slice<=size; slice++) {
			imp.setSlice(slice);
            ImageProcessor ip = imp.getProcessor();
            //ip.setRoi(roi);
            if (minThreshold!=ImageProcessor.NO_THRESHOLD)
                ip.setThreshold(minThreshold,maxThreshold,ImageProcessor.NO_LUT_UPDATE);
			ImageStatistics stats = imp.getStatistics(measurements);
            values[slice-1] = (float)stats.mean;
        }
        imp.setSlice(oldSlice);
        imp.killRoi();
        return values;
    }
    int getZAxisStats(Roi roi, double minThreshold, double maxThreshold, ImageStatistics[] stats){
        ImageStack stack = imp.getStack();
        imp.setRoi(roi);
        int size = stack.getSize();
		int measurements = Analyzer.getMeasurements();
		float[] values = new float[size];
		int oldSlice = imp.getCurrentSlice();
		for (int slice=1; slice<=size; slice++) {
			imp.setSlice(slice);
            ImageProcessor ip = imp.getProcessor();
            //ip.setRoi(roi);
            if (minThreshold!=ImageProcessor.NO_THRESHOLD)
                ip.setThreshold(minThreshold,maxThreshold,ImageProcessor.NO_LUT_UPDATE);
            stats[slice-1] = imp.getStatistics(measurements);
        }
        imp.setSlice(oldSlice);
        imp.killRoi();
        return measurements;
    }
}//class ProteinProfiler

class CircleArranger extends ImageCanvas implements MouseListener, MouseMotionListener {
	public final Object resource = "resource";//For synchronization.
	int napTime = 100;
	protected Thread thread;
	protected long lastUseTime;
	boolean changed = false;
	public boolean done = false;
	ImageCanvas ic;
	Graphics g;
	protected Button spacing, measure, quit;
	int oldSlice;
	//Parameters describing grid
	public int rows,columns,n;
	public int diameter,width,height,roiChoice;
	int w,h;
	public double[] x,y;
	double[] xOld,yOld;
	int activeCircle = -1;
	boolean shift = false;
	boolean ctrl = false;
	boolean meta = false;
	boolean alt = false;
	int xP = 0;
	int yP = 0;
	double mag;
	Vector clickHistory;

	public CircleArranger(ImagePlus imp, ImageCanvas ic, int rows, int columns,
				 int diameter, int width, int height, int roiChoice) {
		super(imp);
		mag = ic.getMagnification();
		w = imp.getWidth();
		h = imp.getHeight();
        //srcRect = new Rectangle(0, 0, iw, ih);
        clickHistory = new Vector(0, 16);

 		this.imp = imp;
		this.ic = ic;
		this.rows = rows;
		this.columns = columns;
		this.diameter = diameter;
		this.width = width;
		this.height = height;
		this.roiChoice = roiChoice;
		initGrid(rows,columns,diameter,width,height,roiChoice);
		g = ic.getGraphics();
		g.setColor(Color.yellow);
		oldSlice = imp.getCurrentSlice();
		int iw = (int)(w*mag);
		int ih = (int)(h*mag);
        setDrawingSize(iw, ih);
       	imp.getWindow().pack();
        //super.setMagnification(mag);
        repaint();
	}
	public void initGrid(int rows, int columns, int diameter, int width, int height, int roiChoice){
		this.rows = rows;
		this.columns = columns;
		this.diameter = diameter;
		this.width = width;
		this.height = height;
		this.roiChoice = roiChoice;
		n = rows*columns;
		x = new double[n];
		y = new double[n];
		xOld = new double[n];
		yOld = new double[n];
		int xStep = w/columns;
		int yStep = h/rows;
		int xStart = 0;
		int yStart = 0;
		if(roiChoice == 0){
			xStart = (xStep - diameter)/2;
			yStart = (yStep - diameter)/2;
		}else{
			xStart = (xStep - width)/2;
			yStart = (yStep - height)/2;
		}
		for (int j = 0; j < rows; j++){
			for (int i = 0; i < columns; i++){
				int ind = i + columns*j;
				x[ind] = xStart + i*xStep + 0.5;
				y[ind] = yStart + j*yStep + 0.5;
			}
		}
		imp.draw();
	}
	public void reviseDiam(int newDiam, int newWidth, int newHeight,  int newRoiChoice){
		roiChoice = newRoiChoice;
		if(roiChoice == 0){
			int del = (newDiam - diameter)/2;
			diameter = newDiam;
			width = newWidth;
			height = newHeight;
			for (int j = 0; j < rows; j++){
				for (int i = 0; i < columns; i++){
					int ind = i + columns*j;
					x[ind] -= del;
					y[ind] -= del;
				}
			}
		}else{
			int delx = (newWidth - width)/2;
			width = newWidth;
			int dely = (newHeight - height)/2;
			height = newHeight;
			diameter = newDiam;			
			for (int j = 0; j < rows; j++){
				for (int i = 0; i < columns; i++){
					int ind = i + columns*j;
					x[ind] -= delx;
					y[ind] -= dely;
				}
			}
		}
		imp.draw();
	}
	public void resetHistory(){
        clickHistory = new Vector(0, 16);
	}
	public void drawCircles(Graphics g){
		synchronized(resource){
			g.setColor(Color.yellow);
			if(roiChoice == 0){
				int diam = (int)(getMagnification()*diameter);
				for (int j = 0; j < rows; j++){
					for (int i = 0; i < columns; i++){
						int ind = i + columns*j;
						g.drawOval(screenX((int)x[ind]),screenX((int)y[ind]),diam,diam);
				
					}
				}
			}else{
				int wd = (int)(getMagnification()*width);
				int ht = (int)(getMagnification()*height);
				for (int j = 0; j < rows; j++){
					for (int i = 0; i < columns; i++){
						int ind = i + columns*j;
						g.drawRect(screenX((int)x[ind]),screenX((int)y[ind]),wd,ht);
				
					}
				}
			}
		}
	}

	public void paint(Graphics g) {
		super.setMagnification(mag);
		super.paint(g);
		drawCircles(g);
	}

	public void shutDown(){
		done = true;
		if(imp!=null)imp.updateAndDraw();
	}

	public void mousePressed(MouseEvent e) {
		activeCircle = -1;
		xP = offScreenX(e.getX());
		yP = offScreenY(e.getY());
		int xPRel = 0;
		int yPRel = 0;
		int limit = 0;
		if(roiChoice == 0){
			xPRel = xP - diameter/2;
			yPRel = yP - diameter/2;
			limit = diameter*diameter/4 + 2;
		}else{
 			xPRel = xP - width/2;
			yPRel = yP - height/2;
			limit = width*height/4 + 2;
		}
		//Find the closest circle to the mouse press
		// April 15, 2012: I know this could be better: test wether press is in ROI.
		int iMin = -1;
		int distMin = Integer.MAX_VALUE;
		int dist;
		for (int i = 0; i < n; i++){
			dist = (xPRel - (int)x[i])*(xPRel - (int)x[i]) + (yPRel - (int)y[i])*(yPRel - (int)y[i]);
			if(dist < distMin){
				distMin = dist;
				iMin = i;
			}
		}
		if(distMin < limit){
			activeCircle = iMin;
			int row = iMin/columns + 1;
			int col = (iMin % columns) + 1;
			IJ.showStatus("("+row+","+col+")");
			clickHistory.addElement(new Integer(activeCircle));			
		}
		int flags = e.getModifiers();
		shift = (flags & Event.SHIFT_MASK) != 0;
		ctrl = (flags & Event.CTRL_MASK) != 0;
		meta = (flags & Event.META_MASK) != 0;//(right button)
		alt = (flags & Event.ALT_MASK) != 0;
	}
	public int getPreviousDistinctActiveCircle(){
		int pointer = clickHistory.size();
		int result = -1;
		while(pointer > 0){
			result = ((Integer)clickHistory.elementAt(--pointer)).intValue();
			if(result != activeCircle)break;
		}
		if(result == activeCircle)result = -1;
		return result;
	}

	public void mouseDragged(MouseEvent e) {
		if(alt){
			//Move all circles
			int xD = offScreenX(e.getX());
			int yD = offScreenY(e.getY());
			int delX = xD - xP;
			int delY = yD - yP;
			int n = x.length;
				for(int i = 0; i < n; i++){
				x[i] += delX;
				y[i] += delY;
			}
			xP = xD;
			yP = yD;
			imp.draw();		
		}else if(shift){
			int iAct = activeCircle % columns;
			int jAct = activeCircle / columns;
			//Strain or rotate array of circles
			int xD = offScreenX(e.getX());
			int yD = offScreenY(e.getY());
			int delX = xD - xP;
			int delY = yD - yP;
			//Find the farthest circles from the mouse press
			int n = x.length;
			//If we are in a corner, scale all distances and angles keeping
			//farthest circle fixed.  If we are not in a corner, but are on an edge keep the farthest
			//edge fixed.
			//Test for corner
			if((activeCircle == 0)||(activeCircle == (columns-1))||(activeCircle == (rows-1)*columns)||(activeCircle == (n-1))){
				double x0 = x[0];
				double y0 = y[0];
				//Set fixed point to previously clicked circle, if one exists, or opposite
				//corner otherwise.
				int prevCircle = getPreviousDistinctActiveCircle();
				if(prevCircle >= 0){
					x0 = x[prevCircle];
					y0 = y[prevCircle];
				}else{
					if(activeCircle == 0){
						x0 = x[n-1];
						y0 = y[n-1];
					}else if(activeCircle == (columns-1)){
						x0 = x[(rows-1)*columns];
						y0 = y[(rows-1)*columns];
					}else if(activeCircle == (rows-1)*columns){
						x0 = x[columns-1];
						y0 = y[columns-1];
					}
				}			
				double xBefore = x[activeCircle] - x0;
				double yBefore = y[activeCircle] - y0;
				double xAfter = xBefore + delX;
				double yAfter = yBefore + delY;
				double rRatio = Math.sqrt(xAfter*xAfter + yAfter*yAfter)/Math.sqrt(xBefore*xBefore + yBefore*yBefore);
				double delTheta = Math.atan2(yAfter,xAfter) - Math.atan2(yBefore,xBefore);					
				for(int i = 0; i < n; i++){
					double xB = x[i] - x0;
					double yB = y[i] - y0;
					double r = Math.sqrt(xB*xB + yB*yB)*rRatio;
					double theta = Math.atan2(yB,xB) + delTheta;
					x[i] = r*Math.cos(theta) + x0;
					y[i] = r*Math.sin(theta) + y0;
				}
			//test for edge.
			}else if ((jAct == 0)||(iAct == (columns - 1))||(jAct == (rows - 1))||(iAct == 0)){
				if(jAct == 0){
					//Clicked on top row.  Keep bottom row fixed.
					int jFix = rows-1;
					for(int i = 0; i < columns; i++){
						double x0 = x[i + columns*jFix];//Fixed point at far side.
						double y0 = y[i + columns*jFix];//Fixed point at far side.
						double xBefore = x[i + jAct*columns] - x0;
						double yBefore = y[i + jAct*columns] - y0;
						double xAfter = xBefore + delX;
						double yAfter = yBefore + delY;
						double rRatio = Math.sqrt(xAfter*xAfter + yAfter*yAfter)/Math.sqrt(xBefore*xBefore + yBefore*yBefore);
						double delTheta = Math.atan2(yAfter,xAfter) - Math.atan2(yBefore,xBefore);
						for(int j = 0; j < (rows-1); j++){
							int ind = i + columns*j;
							double xB = x[ind] - x0;
							double yB = y[ind] - y0;
							double r = Math.sqrt(xB*xB + yB*yB)*rRatio;
							double theta = Math.atan2(yB,xB) + delTheta;
							x[ind] = r*Math.cos(theta) + x0;
							y[ind] = r*Math.sin(theta) + y0;
						}
					}//i
				}else if(jAct == (rows-1)){
					//Clicked on bottom row.  Keep top row fixed.
					int jFix = 0;
					for(int i = 0; i < columns; i++){
						double x0 = x[i + columns*jFix];//Fixed point at far side.
						double y0 = y[i + columns*jFix];//Fixed point at far side.
						double xBefore = x[i + jAct*columns] - x0;
						double yBefore = y[i + jAct*columns] - y0;
						double xAfter = xBefore + delX;
						double yAfter = yBefore + delY;
						double rRatio = Math.sqrt(xAfter*xAfter + yAfter*yAfter)/Math.sqrt(xBefore*xBefore + yBefore*yBefore);
						double delTheta = Math.atan2(yAfter,xAfter) - Math.atan2(yBefore,xBefore);
						for(int j = 1; j < rows; j++){
							int ind = i + columns*j;
							double xB = x[ind] - x0;
							double yB = y[ind] - y0;
							double r = Math.sqrt(xB*xB + yB*yB)*rRatio;
							double theta = Math.atan2(yB,xB) + delTheta;
							x[ind] = r*Math.cos(theta) + x0;
							y[ind] = r*Math.sin(theta) + y0;
						}
					}//i
				}else if(iAct == 0){
					//Clicked on left column.  Keep right column fixed.
					int iFixed = columns-1;
					for(int j = 0; j < rows; j++){
						double x0 = x[iFixed + columns*j];//Fixed point at far side.
						double y0 = y[iFixed + columns*j];//Fixed point at far side.
						double xBefore = x[iAct + j*columns] - x0;
						double yBefore = y[iAct + j*columns] - y0;
						double xAfter = xBefore + delX;
						double yAfter = yBefore + delY;
						double rRatio = Math.sqrt(xAfter*xAfter + yAfter*yAfter)/Math.sqrt(xBefore*xBefore + yBefore*yBefore);
						double delTheta = Math.atan2(yAfter,xAfter) - Math.atan2(yBefore,xBefore);
						for(int i = 0; i < (columns-1); i++){
							int ind = i + columns*j;
							double xB = x[ind] - x0;
							double yB = y[ind] - y0;
							double r = Math.sqrt(xB*xB + yB*yB)*rRatio;
							double theta = Math.atan2(yB,xB) + delTheta;
							x[ind] = r*Math.cos(theta) + x0;
							y[ind] = r*Math.sin(theta) + y0;
						}
					}//j
				}else if(iAct == (columns-1)){
					//Clicked on right column.  Keep left column fixed.
					int iFixed = 0;
					for(int j = 0; j < rows; j++){
						double x0 = x[iFixed + columns*j];//Fixed point at far side.
						double y0 = y[iFixed + columns*j];//Fixed point at far side.
						double xBefore = x[iAct + j*columns] - x0;
						double yBefore = y[iAct + j*columns] - y0;
						double xAfter = xBefore + delX;
						double yAfter = yBefore + delY;
						double rRatio = Math.sqrt(xAfter*xAfter + yAfter*yAfter)/Math.sqrt(xBefore*xBefore + yBefore*yBefore);
						double delTheta = Math.atan2(yAfter,xAfter) - Math.atan2(yBefore,xBefore);
						for(int i = 1; i < columns; i++){
							int ind = i + columns*j;
							double xB = x[ind] - x0;
							double yB = y[ind] - y0;
							double r = Math.sqrt(xB*xB + yB*yB)*rRatio;
							double theta = Math.atan2(yB,xB) + delTheta;
							x[ind] = r*Math.cos(theta) + x0;
							y[ind] = r*Math.sin(theta) + y0;
						}
					}//j
				}
			}//end of shift choices: corners or edges
			xP = xD;
			yP = yD;
			imp.draw();
		}else if(activeCircle >= 0){
			int xD = offScreenX(e.getX());
			int yD = offScreenY(e.getY());
			int delX = xD - xP;
			int delY = yD - yP;
			x[activeCircle] += delX;
			y[activeCircle] += delY;
			xP = xD;
			yP = yD;
			imp.draw();
		}
	}

	public void mouseExited(MouseEvent e) {
		setCursor(new Cursor(Cursor.DEFAULT_CURSOR));
	}

	public void mouseEntered(MouseEvent e) {
		setCursor(new Cursor(Cursor.CROSSHAIR_CURSOR));
	}

	public void mouseReleased(MouseEvent e) {
		activeCircle = -1;
	}
	public void mouseMoved(MouseEvent e) {
		xP = offScreenX(e.getX());
		yP = offScreenY(e.getY());
		int xPRel = 0;
		int yPRel = 0;
		int limit = 0;
		if(roiChoice == 0){
			xPRel = xP - diameter/2;
			yPRel = yP - diameter/2;
			limit = diameter*diameter/4 + 2;
		}else{
 			xPRel = xP - width/2;
			yPRel = yP - height/2;
			limit = width*height/4 + 2;
		}
		//Find the closest circle to the mouse
		int iMin = -1;
		int distMin = Integer.MAX_VALUE;
		int dist;
		for (int i = 0; i < n; i++){
			dist = (xPRel - (int)x[i])*(xPRel - (int)x[i]) + (yPRel - (int)y[i])*(yPRel - (int)y[i]);
			if(dist < distMin){
				distMin = dist;
				iMin = i;
			}
		}
		if(distMin < limit){
			int row = iMin/columns + 1;
			int col = (iMin % columns) + 1;
			IJ.showStatus("("+row+","+col+")");
		}else{
			IJ.showStatus("");
		}
	}
	public void mouseClicked(MouseEvent e) {}

}//class CircleArranger